#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from typing import Tuple, List
from csp import gen_constraint, csp
from fileParser import file_parse
from typing import Dict, Set
from time import time

class GraphColoringRestraint(gen_constraint):
    """
    Subclass of gen_constraint from csp to set up constraints
    variables -> the vertices given to us from the file parser
    domains -> our colors set as a list
    assignments -> set up as a dict where vertex is the key and color is value
    constraints -> the vertices that are adjacent to each other(edges) from
    our file parser
    """
    def __init__(self, vertex1, vertex2):
        super().__init__([vertex1, vertex2])
        self.vertex1 = vertex1
        self.vertex2 = vertex2
        
    def is_satisfied(self, assignment:Dict[int, int])-> bool:
        #checks if either vertcies have been assigned a color if not then return true
        if self.vertex1 not in assignment or self.vertex2 not in assignment:
            return True
        #if both have been assigned check that both are not the same color
        return assignment[self.vertex1] != assignment[self.vertex2]

    """
    Subclass of csp to form graph coloring csp
    inputs:
        edges -> Edges we obtain from our text file
        vertices -> the variables we create from the file parser module
        colors -> initially a int value we use range(colors) to product domains
        we then use add_constraint from the csp module with the use of the 
        GraphcoloringRestraint subclass to form the vertex 1 and vertex 2 
        We don't have to worry about repeating edges such as (1,5) (5,1) as
        we filter these out within the file_parse module
    """
class GraphColoringCSP(csp):
    def __init__(self, vertices: List, edges: Set[Tuple[int, int]], colors: int) -> None:
        self.edges = edges
        self.colors = colors
        self.vertices = vertices 
        domains = {vertex: list(range(colors)) for vertex in vertices}
        super().__init__(vertices, domains)
        for v1, v2 in self.edges:
            self.add_constraint(GraphColoringRestraint(v1,v2))
            
    @classmethod
    def from_file(cls, filename) -> csp:
        fileData = file_parse(filename=filename)
        return cls(**fileData.parsed_data)

if __name__ == "__main__":
    start = time()
    gc = GraphColoringCSP.from_file("gc_78317094521100.txt")
    print(gc.domains)
    end = time()
    print("Parsing Time: ", end-start)
    start = time()
    assignment = gc.backtrack()
    end = time()
    print("Search time:", end-start)